//
//  MainViewController.swift
//  OnLooker
//
//  Created by Jal Irani on 8/8/19.
//  Copyright Â© 2019 Jal Irani. All rights reserved.
//

import UIKit
import Firebase
import Toast_Swift
import OpenTok

class MainViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    
    @IBOutlet weak var videoTableView: UITableView!
    @IBOutlet weak var shareButton: UIButton!
    
    var sections = [" ", "Recent Events"]
    var streamList:[[Stream]] = [[], []]
    var ref: DatabaseReference!
    //TokBox Test
    //In a production application, these credentials should be generated by a server, but to speed things up we will just hard code the values for now:
    // Replace with your OpenTok API key
    var kApiKey = "46536092"
    // Replace with your generated session ID
    var kSessionId = "1_MX40NjUzNjA5Mn5-MTU4NDA1NjY0MTMwNX56elZoa1RweHdiMEFDNU0reWlWTGs0K1Z-fg"
    // Replace with your generated token
    var kToken = "T1==cGFydG5lcl9pZD00NjUzNjA5MiZzaWc9OTEwYzMyNDRmMjJkNzljODU0YjJmNjQ5OGQ2MTJlMWY3MzEyMGY0YTpzZXNzaW9uX2lkPTFfTVg0ME5qVXpOakE1TW41LU1UVTROREExTmpZME1UTXdOWDU2ZWxab2ExUndlSGRpTUVGRE5VMHJlV2xXVEdzMEsxWi1mZyZjcmVhdGVfdGltZT0xNTg0MDU2NjYxJm5vbmNlPTAuMDY3NDk3NDc2MzQzMDMyOTQmcm9sZT1wdWJsaXNoZXImZXhwaXJlX3RpbWU9MTU4NDY2MTQ2MCZpbml0aWFsX2xheW91dF9jbGFzc19saXN0PQ=="
    
    var session: OTSession?
    var publisher: OTPublisher?
    var subscriber: OTSubscriber?
    //TokBox Test
    
    override func viewDidLoad() {
        super.viewDidLoad()
        //TokBox Test
        connectToAnOpenTokSession()
        //TokBox Test
        let backgroundImage = UIImage(named: "onlooker_background_opacity.png")
        let imageView = UIImageView(image: backgroundImage)
        imageView.contentMode = .scaleAspectFill
        self.videoTableView.backgroundView = imageView
        
        ref = Database.database().reference(withPath: "streams")

        ref.observe(.value, with: { snapshot in
            var newItems:[[Stream]] = [[], []]
            for child in snapshot.children {
                if let dataSnap = child as? DataSnapshot {
                    if let item = Stream(snapshot: dataSnap) {
                        if item.type == "important" {
                            newItems[0].append(item)
                        } else if item.active {
                            newItems[1].append(item)
                        }
                    }
                }
            }
            self.streamList = newItems
            self.videoTableView.reloadData()
        })

        videoTableView.delegate = self
        videoTableView.dataSource = self
        
        shareButton.backgroundColor = UIColor(displayP3Red: 0/255.0, green: 106/255.0, blue: 181/255.0, alpha: 1.0)
        shareButton.tintColor = .white
        shareButton.layer.cornerRadius = 8.0
    }
    
    func getCurrentDate() -> String {
        let date = Date()
        let format = DateFormatter()
        format.dateFormat = "yyyy-MM-dd"
        let formattedDate = format.string(from: date)
        return formattedDate
    }
    
    //TokBox Test
    func connectToAnOpenTokSession() {
        session = OTSession(apiKey: kApiKey, sessionId: kSessionId, delegate: self as! OTSessionDelegate)
    var error: OTError?
    session?.connect(withToken: kToken, error: &error)
    if error != nil {
        print(error!)
        }
    }
    //TokBox Test
    
    @IBAction func unwindFromMaster(segue: UIStoryboardSegue) {
        if segue.source is ShareViewController {
            if let shareVC = segue.source as? ShareViewController {
                print("shareVC.submittedData: \(shareVC.submittedData)")
                if shareVC.submittedData {
                    self.view.makeToast("Link has been shared with our team", duration: 5.0, position: .top)
                }
            }
        }
    }
    
    @IBAction func shareButtonTapped(_ sender: Any) {
        print("button tapped")
    }
    
    // MARK: - Navigation
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if segue.destination is VideoViewController {
            let vc = segue.destination as? VideoViewController
            let streamIndex = videoTableView.indexPathForSelectedRow?.row
            let streamSection = videoTableView.indexPathForSelectedRow?.section
            vc?.urlSegue = streamList[streamSection!][streamIndex!].url
        }
    }
}

// MARK: - Tableview Datasource

extension MainViewController {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return streamList[section].count
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return sections.count
    }
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if indexPath.section == 0 {
            return 130
        } else {
            return 60
        }
    }
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return UITableView.automaticDimension
    }
}

// MARK: - Tableview Delegate

extension MainViewController {
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        print("indexPath.section: \(indexPath.section)")
        var cellName = ""
        if indexPath.section == 0 && streamList[indexPath.section][indexPath.row].active  {
            cellName = "breakingVideoCell"
            let cell = tableView.dequeueReusableCell(withIdentifier: cellName, for: indexPath) as! BreakingTableViewCell
            cell.breakingNameLabel.text = streamList[indexPath.section][indexPath.row].name
            return cell
        } else if indexPath.section == 0 && !streamList[indexPath.section][indexPath.row].active {
            cellName = "breakingVideoCellIdle"
            let cell = tableView.dequeueReusableCell(withIdentifier: cellName, for: indexPath) as! IdleBreakingTableViewCell
            //cell.breakingNameLabel.text = streamList[indexPath.section][indexPath.row].name
            return cell
        } else {
            cellName = "subVideoCell"
            let cell = tableView.dequeueReusableCell(withIdentifier: cellName, for: indexPath) as! VideoTableViewCell
            cell.textLabel?.font = UIFont.systemFont(ofSize: 16, weight: .semibold)
            cell.textLabel?.text = streamList[indexPath.section][indexPath.row].name
            return cell
        }
    }
    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
        return sections[section]
    }
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        if section == 0 && sections.count == 2 {
            let vw = UIView()
            
            let imageViewGame = UIImageView(frame: CGRect(x: tableView.frame.width/2 - 72.5, y: 10, width: 145, height: 34));
            let image = UIImage(named: "onlooker_logo.png");
            imageViewGame.image = image;
            imageViewGame.tag = section
            vw.addSubview(imageViewGame)
            return vw
        } else {
            let vw = UIView()
            
            let label = UILabel(frame: CGRect(x: 14, y: 0, width: tableView.frame.width, height: 34))
            label.font = UIFont.systemFont(ofSize: 20, weight: .heavy)
            label.textAlignment = .left
            label.text = sections[section]
            vw.addSubview(label)
            return vw
        }
    }
}

// TokBox Test
// MARK: - OTSessionDelegate callbacks
extension MainViewController: OTSessionDelegate {
   func sessionDidConnect(_ session: OTSession) {
       print("The client connected to the OpenTok session.")
    
        let settings = OTPublisherSettings()
        settings.name = UIDevice.current.name
    guard let publisher = OTPublisher(delegate: self as! OTPublisherKitDelegate, settings: settings) else {
            return
        }

        var error: OTError?
        session.publish(publisher, error: &error)
        guard error == nil else {
            print(error!)
            return
        }

        guard let publisherView = publisher.view else {
            return
        }
        let screenBounds = UIScreen.main.bounds
        publisherView.frame = CGRect(x: screenBounds.width - 150 - 20, y: screenBounds.height - 150 - 20, width: 150, height: 150)
        view.addSubview(publisherView)
    
   }

   func sessionDidDisconnect(_ session: OTSession) {
       print("The client disconnected from the OpenTok session.")
   }

   func session(_ session: OTSession, didFailWithError error: OTError) {
       print("The client failed to connect to the OpenTok session: \(error).")
   }

   func session(_ session: OTSession, streamCreated stream: OTStream) {
       print("A stream was created in the session.")
    subscriber = OTSubscriber(stream: stream, delegate: self as! OTSubscriberKitDelegate)
       guard let subscriber = subscriber else {
           return
       }

       var error: OTError?
       session.subscribe(subscriber, error: &error)
       guard error == nil else {
           print(error!)
           return
       }

       guard let subscriberView = subscriber.view else {
           return
       }
       subscriberView.frame = UIScreen.main.bounds
       view.insertSubview(subscriberView, at: 0)
   }

   func session(_ session: OTSession, streamDestroyed stream: OTStream) {
       print("A stream was destroyed in the session.")
   }
}

// MARK: - OTPublisherDelegate callbacks
extension MainViewController: OTPublisherDelegate {
   func publisher(_ publisher: OTPublisherKit, didFailWithError error: OTError) {
       print("The publisher failed: \(error)")
   }
}

// MARK: - OTSubscriberDelegate callbacks
extension MainViewController: OTSubscriberDelegate {
   public func subscriberDidConnect(toStream subscriber: OTSubscriberKit) {
       print("The subscriber did connect to the stream.")
   }

   public func subscriber(_ subscriber: OTSubscriberKit, didFailWithError error: OTError) {
       print("The subscriber failed to connect to the stream.")
   }
}
//TokBoxk Test
